package generate_sf_enterprise_structs

import (
	"bytes"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	sfclient "github.com/Silicon-Ally/etap2sf/salesforce/clients/metadata/utils"
	"github.com/Silicon-Ally/etap2sf/salesforce/generated/sfmetadata"
	"github.com/Silicon-Ally/etap2sf/utils"
)

func generateEnums() error {
	evs, err := getAllEnumValues()
	if err != nil {
		return fmt.Errorf("getting all enum values: %w", err)
	}

	pathToSFEnterprise := filepath.Join(utils.ProjectRoot(), "salesforce", "generated", "sfenterprise", "sfenterprise.wsdl")
	sfedata, err := os.ReadFile(pathToSFEnterprise)
	if err != nil {
		return fmt.Errorf("reading sfenterprise.wsdl: %w", err)
	}

	sfenterprise := string(sfedata)

	replaceTypeName := func(objectName, fieldName, replacement string) error {
		idxA := strings.Index(sfenterprise, fmt.Sprintf(`<complexType name="%s">`, objectName))
		if idxA == -1 {
			return fmt.Errorf("could not find complex type for object %s", objectName)
		}
		afterA := sfenterprise[idxA:]
		idxB := strings.Index(afterA, fmt.Sprintf(`<element name="%s"`, fieldName))
		if idxB == -1 {
			return fmt.Errorf("could not find element for field %s", fieldName)
		}
		afterB := afterA[idxB:]
		originalType := `type="xsd:string"`
		idxC := strings.Index(afterB, originalType)
		idxD := strings.Index(afterB, `/>`)
		if idxC == -1 || idxC > idxD {
			return fmt.Errorf("could not find type for field %s", fieldName)
		}
		idx := idxA + idxB + idxC
		sfenterprise = sfenterprise[:idx] + `type="` + replacement + `"` + sfenterprise[idx+len(originalType):]
		return nil
	}

	parseFns := []string{}
	stanzas := []string{}
	for objectName, fieldMap := range evs {
		if strings.HasSuffix(objectName, "ChangeEvent") {
			// These are not defined in the WSDL, and aren't accessible for writes by APIs, so we omit them.
			continue
		}
		if strings.HasPrefix(objectName, "AIRecord") || strings.HasPrefix(objectName, "AIInsight") {
			// These enums are enormous and useless for our purposes.
			continue
		}
		if strings.HasPrefix(objectName, "OutgoingEmail") {
			// This field isn't important to the migration.
			continue
		}
		for fieldName, enumValues := range fieldMap {
			if fieldName == "etap_EtapSystem_DataSource__c" {
				continue
			}
			/*
				on := strings.ToLower(utils.AlphanumericOnly(objectName))
				fn := strings.ToLower(utils.AlphanumericOnly(fieldName))
				typeName := strings.ToUpper(on[0:1]) + on[1:] + strings.ToUpper(fn[0:1]) + fn[1:]
			*/
			typeName := fmt.Sprintf("%s_%s_",
				utils.AlphanumericOnly(strings.TrimSuffix(objectName, "__c")),
				utils.AlphanumericOnly(strings.TrimSuffix(fieldName, "__c")))
			typeName = strings.ToUpper(typeName[0:1]) + typeName[1:]
			stanza := fmt.Sprintf(`<xsd:simpleType name="%s"><xsd:restriction base="xs:string">`, typeName)
			m := map[string]bool{}
			cases := []string{}
			for _, enumValue := range enumValues {
				value := escapeXML(enumValue.Value)
				mv := strings.ToLower(value)
				if m[mv] {
					continue
				}
				m[mv] = true
				stanza += fmt.Sprintf(`<xsd:enumeration value="%s"/>`, value)
				ano := keepEnumValueValidChars(enumValue.Value)
				goEnumName := typeName + strings.ToUpper(ano[0:1]) + ano[1:]
				cases = append(cases, fmt.Sprintf(`
	case "%s":
		return %s, nil`, enumValue.Value, goEnumName))
			}
			stanza += "</xsd:restriction></xsd:simpleType>"
			stanzas = append(stanzas, stanza)
			if err := replaceTypeName(objectName, fieldName, typeName); err != nil {
				return fmt.Errorf("replacing type name: %w", err)
			}
			golangEnumName := typeName
			parseFn := fmt.Sprintf(`
func Parse_%[1]s(s string) (%[1]s, error) {
	switch(s) {
	%[2]s
	}
	return "", fmt.Errorf("parse error: couldn't find %[1]s value for %[3]s", s)
}
`, golangEnumName, strings.Join(cases, ""), "%q")
			parseFns = append(parseFns, parseFn)
		}
	}

	idx := strings.Index(sfenterprise, "<complexType")
	sfenterprise = sfenterprise[:idx] + strings.Join(stanzas, "\n") + sfenterprise[idx:]

	if err := os.WriteFile(pathToSFEnterprise, []byte(sfenterprise), 0644); err != nil {
		return fmt.Errorf("writing sfenterprise-modified.wsdl: %w", err)
	}

	parsers := fmt.Sprintf(`
package sfenterprise

import "fmt"

// Code generated by generate/enums; DO NOT EDIT.

%s
`, strings.Join(parseFns, "\n"))
	if err := os.WriteFile(filepath.Join(utils.ProjectRoot(), "salesforce", "generated", "sfenterprise", "generated-enum-parsers.go"), []byte(parsers), 0644); err != nil {
		return fmt.Errorf("writing enum-parsers.go: %w", err)
	}

	return nil
}

func keepEnumValueValidChars(s string) string {
	result := strings.Builder{}
	for _, r := range s {
		if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' {
			result.WriteRune(r)
		} else if r == '.' {
			result.WriteRune('_')
		}

	}
	return result.String()
}

func getAllEnumValues() (map[string]map[string][]*sfmetadata.PicklistEntry, error) {
	data, err := utils.MemoizeOperation("salesforce-enum-values.json", doGetAllEnumValues)
	if err != nil {
		return nil, fmt.Errorf("memoizing operation: %w", err)
	}
	result := map[string]map[string][]*sfmetadata.PicklistEntry{}
	if err := json.Unmarshal(data, &result); err != nil {
		return nil, fmt.Errorf("unmarshaling data: %w", err)
	}
	return result, nil
}

func doGetAllEnumValues() ([]byte, error) {
	client, err := sfclient.NewMetadataSandboxClient()
	if err != nil {
		return nil, fmt.Errorf("creating client: %w", err)
	}
	aevs, err := client.GetAllEnumValues()
	if err != nil {
		return nil, fmt.Errorf("getting all enum values: %w", err)
	}
	data, err := json.MarshalIndent(aevs, "", "  ")
	if err != nil {
		return nil, fmt.Errorf("marshaling aevs: %w", err)
	}
	return data, nil
}

func escapeXML(s string) string {
	var b bytes.Buffer
	if err := xml.EscapeText(&b, []byte(s)); err != nil {
		log.Printf("failed to escape XML: %v", err)
	}
	return b.String()
}
